issue：
所给出的用邻接表表示的无向图的源码，其删除顶点的函数是有问题的。目前还不清楚如何解决这一问题。在命令行中用gcc可以编译并按照预期运行，但是利用cmake或vscode的task，或者在gdbonline中，都无法顺利执行删除顶点的操作。虽然后几者运行时也没有报错，但是在入口函数里，删除函数以及之后的函数都没有顺利运行，没有产生任何效果。经过调试，发现在执行删除顶点的操作时，程序进入了死循环。猜测是gcc做出了优化，而其它编译运行的方式则更像是从这个死循环直接终止了程序，强制性地返回了0。总之这里有问题。(20240615)

solution:
在这一函数里，在删除了以待删除的顶点为头节点的链表之后，继续执行遍历其它链表以找到在其它链表中作为邻接节点的顶点的操作。但原节点对应的链表在被删除后，其头节点以及其邻接节点都已经被free释放。这些节点都成为了悬空指针，所以，不应该再利用这些被释放的指针去访问其所指向的内存空间。除此之外，从逻辑上讲，这一链表也不需要再次遍历，因为它是应该被直接删除的，而不是修改的。因此，在遍历其它顶点的链表时以找到其它链表中的顶点时，不应该访问先前已经被释放的链表。解决这一问题，添加一个if语句即可。(20240616)

关于邻接表表示的图的析构：
在理解析构顺序时，还是需要区分顶点(vertex)和头节点(adjlistnode)。不论是添加顶点，还是添加边，其实现方式都是添加了一个全新的头节点adjlistnode上去(注意不是vertex)，即都是利用malloc函数分配了一块新的内存，并将这一新的节点adjlistnode连接到图和链表中去(而vertex，是间接通过adjlistnode来访问的、发挥作用的)。vertex是adjlistnode的一个属性，一般的析构流程告诉我们先释放属性，再释放整个结构体。但这种考虑是为了避免我们忘记对属性的释放，因为如果直接释放了结构体，就会有概率不能寻址到其下的结构体，而不是一种必然的流程。事实上，如果按照这种流程，那么在析构时就会发生重复释放vertex内存的情况，这会发生错误。于vertex的释放，得是在真正需要删除顶点的时候才去删除，即在delgraph函数里和removevertex函数里。
