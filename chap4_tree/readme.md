所谓的构造函数，就是让结构体初始化。所以，阅读、写构造函数的一个思路是，让结构体内的属性被完整地初始化，避免段错误、未定义的值等等行为。相应的，这也关系到结构体，就写的这个结构体，是为了做什么事情，内核是链表，还是数组，是用的数组，还是利用的链表来存放的数据。最后，是用来实现散列数据结构的，还是栈、还是队列，还是二叉树。

链表分散的。数组是连续的。但是，这丝毫不影响一个数组里面存放各种各样的地址（a,b,c,d)，数组强调的是，可以通过arr[index]，index的偏移量来进行访问a,b,c,d，而a,b,c,d之间可以是链表关系，也完全可以不是链表关系。而如果是链表，则可以通过->操作符来完成这种访问。

递归的确是深度优先遍历二叉树的最佳办法。仅仅以遍历举例的话，一个return里面就蕴含着什么时候递，什么时候归的哲学，以不同的顺序进行的递归调用，保证了遍历的顺序。如，是前序，还是中序，还是后序。（貌似广度优先没有用到递归，它依赖的是队列的哲学。）

20240601：
avl树和二叉搜索树相比，复杂一点的地方在于对树的整个逻辑的关注，考虑到了树的重新链接，所以删除也好，插入也好，都不是增添或删除那么简单。因此，可以理解的是，为什么remove函数在avltree里有一个返回值，在bst里却不需要。类似的，插入也是一样。给我一个根节点，我还你一棵新树。

左旋右旋，先左旋后右旋，或者是先右旋后左旋，这四种操作方式应该在抽象的意义上理解，从而对应四种抽象的adt，当然，它们都是树。四种抽象足够穷尽所有的具体的不平衡的现象。

从顶至底向下探测（递），从底至顶（归）更新(包括avltree节点的更新)、链接。这再一次表现出包括avltree这种特殊形态的树在内的二叉树同递归的亲密关系。

在二叉树中，分清楚变的和不需要变的情况是有益于理解的。没有想象得那么复杂和没有规律。尤其是有的指向是没有变的，这个节点不再是父节点，可能意味着它不能指向原版的左右两个子节点，但不妨碍它依旧能指向其中某一个子节点。总之，左旋右旋只是一种比喻，不要将它太过与风筝的意向联系起来。很多引用关系是没有发生变化的。

node-child-grandchild，是这样划线的。
2^2 = 4
